// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package queries

import (
	"context"
	"time"
)

const addChunk = `-- name: AddChunk :exec
insert into
    chunks (
        doc_id,
        position,
        value,
        suffix
    )
values
    (?1, ?2, ?3, ?4)
`

type AddChunkParams struct {
	DocID    int64
	Position int64
	Value    string
	Suffix   string
}

func (q *Queries) AddChunk(ctx context.Context, arg AddChunkParams) error {
	_, err := q.db.ExecContext(ctx, addChunk,
		arg.DocID,
		arg.Position,
		arg.Value,
		arg.Suffix,
	)
	return err
}

const addDoc = `-- name: AddDoc :one
insert into
    docs(
        title,
        author,
        notes,
        lang_id,
        user_id,
        added_at,
        term_count,
        sentence_count,
        terms_new
    )
values
    (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        datetime(),
        0,
        0,
        0
    ) returning doc_id
`

type AddDocParams struct {
	Title  string
	Author string
	Notes  string
	LangID int64
	UserID int64
}

func (q *Queries) AddDoc(ctx context.Context, arg AddDocParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addDoc,
		arg.Title,
		arg.Author,
		arg.Notes,
		arg.LangID,
		arg.UserID,
	)
	var doc_id int64
	err := row.Scan(&doc_id)
	return doc_id, err
}

const addLang = `-- name: AddLang :one
insert into
    langs(
        name,
        from_id,
        to_id,
        quick_lookup_uri,
        lookup_uri_1,
        lookup_uri_2,
        chars_pattern,
        sentence_sep,
        added_at,
        user_id
    )
values
    (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        datetime(),
        ?9
    ) returning lang_id
`

type AddLangParams struct {
	Name           string
	FromID         string
	ToID           string
	QuickLookupURI string
	LookupURI1     string
	LookupURI2     string
	CharsPattern   string
	SentenceSep    string
	UserID         int64
}

func (q *Queries) AddLang(ctx context.Context, arg AddLangParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addLang,
		arg.Name,
		arg.FromID,
		arg.ToID,
		arg.QuickLookupURI,
		arg.LookupURI1,
		arg.LookupURI2,
		arg.CharsPattern,
		arg.SentenceSep,
		arg.UserID,
	)
	var lang_id int64
	err := row.Scan(&lang_id)
	return lang_id, err
}

const addTerms = `-- name: AddTerms :exec
insert into
    terms(
        value,
        translation,
        term_level_id,
        lang_id,
        user_id,
        added_at
    )
select
    c.value,
    '',
    1,
    d.lang_id,
    d.user_id,
    datetime()
from
    chunks c
    join docs d on c.doc_id = d.doc_id
where
    d.doc_id = ?1
    and c.value not in (
        select
            value
        from
            terms
        where
            user_id = (
                select
                    user_id
                from
                    docs
                where
                    doc_id = d.doc_id
            )
    )
group by
    value
`

func (q *Queries) AddTerms(ctx context.Context, docID int64) error {
	_, err := q.db.ExecContext(ctx, addTerms, docID)
	return err
}

const getAllLangs = `-- name: GetAllLangs :many
select
    id,
    name
from
    langs_dim
`

func (q *Queries) GetAllLangs(ctx context.Context) ([]LangsDim, error) {
	rows, err := q.db.QueryContext(ctx, getAllLangs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LangsDim
	for rows.Next() {
		var i LangsDim
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocBody = `-- name: GetDocBody :many
select
    c.value,
    c.suffix,
    case when t.term_level_id is null then 1 else t.term_level_id end as term_level_id,
    case when t.translation is null then '' else t.translation end as translation
from
    chunks c
    left join terms t 
        on c.value = t.value and t.user_id = ?1
where
    c.doc_id = ?2
`

type GetDocBodyParams struct {
	UserID int64
	DocID  int64
}

type GetDocBodyRow struct {
	Value       string
	Suffix      string
	TermLevelID interface{}
	Translation interface{}
}

func (q *Queries) GetDocBody(ctx context.Context, arg GetDocBodyParams) ([]GetDocBodyRow, error) {
	rows, err := q.db.QueryContext(ctx, getDocBody, arg.UserID, arg.DocID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocBodyRow
	for rows.Next() {
		var i GetDocBodyRow
		if err := rows.Scan(
			&i.Value,
			&i.Suffix,
			&i.TermLevelID,
			&i.Translation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocMeta = `-- name: GetDocMeta :one
select
    doc_id,
    title,
    author,
    notes,
    d.added_at,
    term_count,
    sentence_count,
    terms_new,
    from_id from_lang_id,
    to_id to_lang_id,
    quick_lookup_uri,
    lookup_uri_1,
    lookup_uri_2,
    chars_pattern,
    sentence_sep
from
    docs d
    join langs l on d.lang_id = l.lang_id
where
    doc_id = ?1
`

type GetDocMetaRow struct {
	DocID          int64
	Title          string
	Author         string
	Notes          string
	AddedAt        time.Time
	TermCount      int64
	SentenceCount  int64
	TermsNew       int64
	FromLangID     string
	ToLangID       string
	QuickLookupUri string
	LookupUri1     string
	LookupUri2     string
	CharsPattern   string
	SentenceSep    string
}

func (q *Queries) GetDocMeta(ctx context.Context, id int64) (GetDocMetaRow, error) {
	row := q.db.QueryRowContext(ctx, getDocMeta, id)
	var i GetDocMetaRow
	err := row.Scan(
		&i.DocID,
		&i.Title,
		&i.Author,
		&i.Notes,
		&i.AddedAt,
		&i.TermCount,
		&i.SentenceCount,
		&i.TermsNew,
		&i.FromLangID,
		&i.ToLangID,
		&i.QuickLookupUri,
		&i.LookupUri1,
		&i.LookupUri2,
		&i.CharsPattern,
		&i.SentenceSep,
	)
	return i, err
}

const getDocs = `-- name: GetDocs :many
select
    doc_id,
    title,
    author,
    added_at,
    term_count,
    terms_new,
    sentence_count
from
    docs
where
    user_id = ?1
`

type GetDocsRow struct {
	DocID         int64
	Title         string
	Author        string
	AddedAt       time.Time
	TermCount     int64
	TermsNew      int64
	SentenceCount int64
}

func (q *Queries) GetDocs(ctx context.Context, userID int64) ([]GetDocsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDocs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocsRow
	for rows.Next() {
		var i GetDocsRow
		if err := rows.Scan(
			&i.DocID,
			&i.Title,
			&i.Author,
			&i.AddedAt,
			&i.TermCount,
			&i.TermsNew,
			&i.SentenceCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLangs = `-- name: GetLangs :many
select
    lang_id,
    name
from
    langs
where
    user_id = ?1
`

type GetLangsRow struct {
	LangID int64
	Name   string
}

func (q *Queries) GetLangs(ctx context.Context, userID int64) ([]GetLangsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLangs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLangsRow
	for rows.Next() {
		var i GetLangsRow
		if err := rows.Scan(&i.LangID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTerm = `-- name: GetTerm :one
select
    term_id,
    value,
    translation
from 
    terms
where 
    value = ?1 
    and lang_id = (select lang_id from docs d where d.doc_id = ?2) 
    and user_id = (select user_id from docs d where d.doc_id = ?2)
`

type GetTermParams struct {
	Value string
	DocID int64
}

type GetTermRow struct {
	TermID      int64
	Value       string
	Translation string
}

func (q *Queries) GetTerm(ctx context.Context, arg GetTermParams) (GetTermRow, error) {
	row := q.db.QueryRowContext(ctx, getTerm, arg.Value, arg.DocID)
	var i GetTermRow
	err := row.Scan(&i.TermID, &i.Value, &i.Translation)
	return i, err
}

const updateDocStats = `-- name: UpdateDocStats :exec
update
    docs
set
    term_count = ?1,
    sentence_count = ?2
where
    doc_id = ?3
`

type UpdateDocStatsParams struct {
	TermCount     int64
	SentenceCount int64
	DocID         int64
}

func (q *Queries) UpdateDocStats(ctx context.Context, arg UpdateDocStatsParams) error {
	_, err := q.db.ExecContext(ctx, updateDocStats, arg.TermCount, arg.SentenceCount, arg.DocID)
	return err
}

const updateTerm = `-- name: UpdateTerm :exec
update 
    terms
set 
    translation = case when ?1 = '' then translation else ?1 end, 
    term_level_id = case when ?2 = '' then term_level_id else ?2 end
where
    term_id = ?3
`

type UpdateTermParams struct {
	Translation interface{}
	LevelID     interface{}
	TermID      int64
}

func (q *Queries) UpdateTerm(ctx context.Context, arg UpdateTermParams) error {
	_, err := q.db.ExecContext(ctx, updateTerm, arg.Translation, arg.LevelID, arg.TermID)
	return err
}
